/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MentionsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var DEFAULT_SETTINGS = {
  debugMode: false,
  autoUpdateProperties: true,
  propertiesFieldName: "mentions"
};
var DebugLogger = class {
  constructor(enabled = false) {
    this.enabled = enabled;
  }
  setEnabled(enabled) {
    this.enabled = enabled;
  }
  log(...args) {
    if (this.enabled) {
      console.log("[Mentions Debug]:", ...args);
    }
  }
};
var MentionsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(plugin) {
    super(plugin.app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Enable debug logging in the console").addToggle((toggle) => toggle.setValue(this.plugin.settings.debugMode).onChange(async (value) => {
      this.plugin.settings.debugMode = value;
      this.plugin.debugLogger.setEnabled(value);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto-update properties").setDesc("Automatically update mentions in file properties when document changes").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoUpdateProperties).onChange(async (value) => {
      this.plugin.settings.autoUpdateProperties = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Properties field name").setDesc("Name of the property field to store mentions (default: mentions)").addText((text) => text.setPlaceholder("mentions").setValue(this.plugin.settings.propertiesFieldName).onChange(async (value) => {
      this.plugin.settings.propertiesFieldName = value || "mentions";
      await this.plugin.saveSettings();
    }));
  }
};
var VIEW_TYPE_MENTIONS = "mentions-view";
var MentionSuggest = class extends import_obsidian.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line);
    const subString = line.substring(0, cursor.ch);
    const match = subString.match(/(?:^|\s)(@[a-zа-я.-]*)$/);
    this.plugin.debugLogger.log("MentionSuggest.onTrigger:", { line, subString, match });
    if (!match)
      return null;
    return {
      start: {
        line: cursor.line,
        ch: match.index + match[0].indexOf("@")
      },
      end: cursor,
      query: match[1].slice(1)
    };
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    const mentions = this.plugin.getMentions();
    this.plugin.debugLogger.log("Raw mentions from plugin:", mentions);
    const uniqueMentions = new Set(mentions.map((m) => m.text));
    this.plugin.debugLogger.log("Unique mentions:", Array.from(uniqueMentions));
    const suggestions = Array.from(uniqueMentions).filter((mention) => mention.toLowerCase().includes(query)).sort();
    this.plugin.debugLogger.log("MentionSuggest.getSuggestions:", {
      query,
      mentionsCount: mentions.length,
      suggestionsCount: suggestions.length,
      suggestions,
      uniqueMentionsCount: uniqueMentions.size
    });
    return suggestions;
  }
  renderSuggestion(value, el) {
    el.createEl("div", { text: value });
  }
  selectSuggestion(value) {
    const { context } = this;
    if (context) {
      const editor = context.editor;
      editor.replaceRange(
        value + " ",
        { line: context.start.line, ch: context.start.ch },
        context.end
      );
      const newCursorPos = {
        line: context.end.line,
        ch: context.start.ch + value.length + 1
      };
      editor.setCursor(newCursorPos);
    }
  }
};
var MentionsView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.mentions = [];
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_MENTIONS;
  }
  getIcon() {
    return "at-sign";
  }
  getDisplayText() {
    return "People mentions";
  }
  async setMentions(mentions) {
    this.mentions = mentions;
    await this.refresh();
  }
  async refresh() {
    const container = this.containerEl.children[1];
    container.empty();
    const headerContainer = container.createEl("div", { cls: "mentions-header" });
    headerContainer.createEl("h2", { text: "People mentions", cls: "mentions-title" });
    const refreshButton = headerContainer.createEl("button", {
      cls: "mentions-refresh-button",
      text: "\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C",
      attr: { "aria-label": "Refresh all mentions" }
    });
    refreshButton.addEventListener("click", async () => {
      refreshButton.addClass("refreshing");
      await this.plugin.refreshAllMentions();
      refreshButton.removeClass("refreshing");
    });
    const updatePropertiesButton = headerContainer.createEl("button", {
      cls: "mentions-update-properties-button",
      text: "\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C Properties",
      attr: { "aria-label": "Update mentions in all file properties" }
    });
    updatePropertiesButton.addEventListener("click", async () => {
      updatePropertiesButton.addClass("refreshing");
      await this.plugin.updateMentionsForAllFiles();
      updatePropertiesButton.removeClass("refreshing");
    });
    const mentionGroups = /* @__PURE__ */ new Map();
    this.mentions.forEach((mention) => {
      const existingGroup = mentionGroups.get(mention.text) || [];
      mentionGroups.set(mention.text, [...existingGroup, mention]);
    });
    const mentionsList = container.createEl("ul", { cls: "mentions-list" });
    const sortedMentions = Array.from(mentionGroups.entries()).sort(([a], [b]) => a.localeCompare(b));
    sortedMentions.forEach(([mentionText, mentions]) => {
      const uniqueFiles = new Set(mentions.map((m) => m.file));
      const fileCount = uniqueFiles.size;
      const item = mentionsList.createEl("li", { cls: "mentions-list-item" });
      item.createEl("strong", { text: mentionText });
      item.createEl("br");
      item.createEl("span", {
        text: `Found in ${fileCount} file${fileCount !== 1 ? "s" : ""}`,
        cls: "mention-file-count"
      });
      item.addEventListener("click", () => {
        const searchLeaf = this.app.workspace.getLeavesOfType("search")[0] || this.app.workspace.getRightLeaf(false);
        searchLeaf.setViewState({
          type: "search",
          state: { query: mentionText }
        });
        this.app.workspace.revealLeaf(searchLeaf);
      });
    });
  }
};
var MentionsPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.mentions = [];
    this.editorDecorations = /* @__PURE__ */ new Map();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.debugLogger = new DebugLogger(this.settings.debugMode);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  getMentions() {
    this.debugLogger.log("Getting mentions:", this.mentions);
    return this.mentions;
  }
  /**
   * Extract mentions from file content
   */
  extractMentionsFromContent(content) {
    const matches = content.match(/(?:^|\s)(@[a-zа-я.-]+)(?=\s|$|[^\w.-])/g);
    if (!matches)
      return [];
    const mentions = matches.map((match) => {
      const cleanMatch = match.replace(/^\s*/, "");
      const mention = cleanMatch.substring(1);
      return mention.replace(/[.,!?;:]+$/, "");
    });
    return [...new Set(mentions)];
  }
  /**
   * Update file properties with mentions
   */
  async updateFileProperties(file, mentions) {
    try {
      this.debugLogger.log("Updating file properties for:", file.path, "with mentions:", mentions);
      const content = await this.app.vault.read(file);
      const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n/;
      const frontmatterMatch = content.match(frontmatterRegex);
      let frontmatter = {};
      let bodyContent = content;
      let frontmatterString = "";
      if (frontmatterMatch) {
        frontmatterString = frontmatterMatch[1];
        bodyContent = content.replace(frontmatterRegex, "");
        try {
          frontmatterString.split("\n").forEach((line) => {
            const match = line.match(/^(\w+):\s*(.*)$/);
            if (match) {
              const [, key, value] = match;
              if (value.startsWith("[") && value.endsWith("]")) {
                const arrayContent = value.slice(1, -1);
                if (arrayContent.trim()) {
                  frontmatter[key] = arrayContent.split(",").map((item) => item.trim().replace(/['"]/g, ""));
                } else {
                  frontmatter[key] = [];
                }
              } else {
                frontmatter[key] = value.replace(/['"]/g, "");
              }
            }
          });
        } catch (error) {
          this.debugLogger.log("Error parsing frontmatter:", error);
        }
      }
      frontmatter[this.settings.propertiesFieldName] = mentions;
      const newFrontmatterLines = Object.entries(frontmatter).map(([key, value]) => {
        if (Array.isArray(value)) {
          if (value.length === 0) {
            return `${key}: []`;
          }
          return `${key}: [${value.map((v) => `"${v}"`).join(", ")}]`;
        } else {
          return `${key}: "${value}"`;
        }
      });
      const newFrontmatter = newFrontmatterLines.length > 0 ? `---
${newFrontmatterLines.join("\n")}
---
` : "";
      const newContent = newFrontmatter + bodyContent;
      await this.app.vault.modify(file, newContent);
      this.debugLogger.log("File properties updated successfully for:", file.path);
    } catch (error) {
      console.error("Error updating file properties:", error);
      new import_obsidian.Notice(`Error updating properties for ${file.name}: ${error.message}`);
    }
  }
  /**
   * Update properties for a specific file
   */
  async updateMentionsForFile(file) {
    try {
      const content = await this.app.vault.read(file);
      const mentions = this.extractMentionsFromContent(content);
      await this.updateFileProperties(file, mentions);
      new import_obsidian.Notice(`Updated mentions for ${file.name}`);
    } catch (error) {
      console.error("Error updating mentions for file:", error);
      new import_obsidian.Notice(`Error updating mentions for ${file.name}`);
    }
  }
  /**
   * Update properties for all markdown files
   */
  async updateMentionsForAllFiles() {
    try {
      const files = this.app.vault.getMarkdownFiles();
      let updatedCount = 0;
      for (const file of files) {
        const content = await this.app.vault.read(file);
        const mentions = this.extractMentionsFromContent(content);
        if (mentions.length > 0) {
          await this.updateFileProperties(file, mentions);
          updatedCount++;
        }
      }
      new import_obsidian.Notice(`Updated mentions for ${updatedCount} files`);
    } catch (error) {
      console.error("Error updating mentions for all files:", error);
      new import_obsidian.Notice("Error updating mentions for all files");
    }
  }
  async refreshAllMentions() {
    this.debugLogger.log("Starting full mentions refresh...");
    this.mentions = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      const content = await this.app.vault.read(file);
      const matches = content.match(/(?:^|\s)(@[a-zа-я.-]+)/g);
      if (matches) {
        matches.forEach((match) => {
          const cleanMatch = match.replace(/^\s*/, "");
          const position = content.indexOf(match);
          const exists = this.mentions.some(
            (m) => m.text === cleanMatch && m.file === file.path && m.position === position
          );
          if (!exists) {
            this.mentions.push({
              text: cleanMatch,
              file: file.path,
              position
            });
          }
        });
      }
    }
    this.debugLogger.log("Mentions refresh completed:", this.mentions);
    if (this.mentionsView) {
      await this.mentionsView.setMentions(this.mentions);
    }
    await this.saveData(this.mentions);
    new import_obsidian.Notice("Mentions refreshed successfully");
  }
  searchMentions(mentionText) {
    const searchText = mentionText.startsWith("@") ? mentionText : "@" + mentionText;
    console.log("Searching for mentions:", {
      searchText,
      currentMentions: this.mentions,
      matchingMentions: this.mentions.filter((mention) => {
        const cleanMention = mention.text.trim();
        return cleanMention === searchText;
      })
    });
    return this.mentions.filter((mention) => {
      const cleanMention = mention.text.trim();
      return cleanMention === searchText;
    });
  }
  async showMentionResults(mentionText) {
    console.log("Showing mention results for:", mentionText);
    const results = this.searchMentions(mentionText);
    console.log("Search results:", results);
    if (results.length > 0) {
      if (this.mentionsView) {
        await this.mentionsView.setMentions(results);
        await this.activateMentionsView();
      }
      new import_obsidian.Notice(`Found ${results.length} mentions of ${mentionText}`);
    } else {
      new import_obsidian.Notice(`No mentions found for ${mentionText}`);
    }
  }
  async activateMentionsView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_MENTIONS)[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({
          type: VIEW_TYPE_MENTIONS,
          active: true,
          history: false
        });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
      if (this.mentionsView) {
        await this.mentionsView.setMentions(this.mentions);
      }
    }
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new MentionsSettingTab(this));
    console.log("MentionsPlugin loading...");
    const mentionStyles = document.createElement("style");
    mentionStyles.textContent = `
            .mention-tag {
                color: var(--text-accent);
                background-color: var(--background-modifier-border);
                padding: 0 4px;
                border-radius: 4px;
                cursor: pointer;
                display: inline-block;
                transition: background-color 0.2s ease;
                white-space: nowrap;
                line-height: normal;
            }
            .mention-tag:hover {
                background-color: var(--background-modifier-border-hover);
            }
            .mentions-list-item {
                padding: 8px;
                margin: 4px 0;
                border-radius: 4px;
                cursor: pointer;
                transition: background-color 0.2s ease;
            }
            .mentions-list-item:hover {
                background-color: var(--background-modifier-border);
            }
            .mention-file-count {
                color: var(--text-muted);
                font-size: 0.9em;
            }
            .mentions-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 16px;
                flex-wrap: wrap;
                gap: 8px;
            }
            .mentions-title {
                margin: 0;
                flex: 1;
            }
            .mentions-refresh-button,
            .mentions-update-properties-button {
                padding: 4px 8px;
                font-size: 0.8em;
                border: 1px solid var(--background-modifier-border);
                border-radius: 4px;
                background: var(--background-primary);
                color: var(--text-normal);
                cursor: pointer;
                transition: all 0.2s ease;
            }
            .mentions-refresh-button:hover,
            .mentions-update-properties-button:hover {
                background: var(--background-modifier-border);
            }
            .mentions-refresh-button.refreshing,
            .mentions-update-properties-button.refreshing {
                opacity: 0.6;
                cursor: not-allowed;
            }
        `;
    document.head.appendChild(mentionStyles);
    this.registerView(
      VIEW_TYPE_MENTIONS,
      (leaf) => this.mentionsView = new MentionsView(leaf, this)
    );
    this.mentionSuggest = new MentionSuggest(this);
    this.registerEditorSuggest(this.mentionSuggest);
    this.registerEditorExtension([
      this.decorateMentions()
    ]);
    this.addRibbonIcon("at-sign", "Show People mentions", () => {
      this.activateMentionsView();
    });
    this.addCommand({
      id: "show-mentions-view",
      name: "Show People mentions View",
      callback: () => {
        this.activateMentionsView();
      }
    });
    this.addCommand({
      id: "update-current-file-mentions",
      name: "Update mentions in current file properties",
      editorCallback: (editor, view) => {
        if (view.file) {
          this.updateMentionsForFile(view.file);
        }
      }
    });
    this.addCommand({
      id: "update-all-files-mentions",
      name: "Update mentions in all files properties",
      callback: () => {
        this.updateMentionsForAllFiles();
      }
    });
    try {
      const savedMentions = await this.loadData();
      console.log("Loading mentions from storage:", {
        savedMentions,
        hasData: !!savedMentions,
        dataType: typeof savedMentions
      });
      if (savedMentions) {
        this.mentions = savedMentions;
        console.log("Mentions loaded into memory:", this.mentions);
      }
      console.log("Processing existing files for mentions...");
      const files = this.app.vault.getMarkdownFiles();
      for (const file of files) {
        const content = await this.app.vault.read(file);
        const matches = content.match(/(?:^|\s)(@[a-zа-я.-]+)/g);
        if (matches) {
          console.log(`Found mentions in ${file.path}:`, matches);
          matches.forEach((match) => {
            const cleanMatch = match.replace(/^\s*/, "");
            const position = content.indexOf(match);
            const exists = this.mentions.some(
              (m) => m.text === cleanMatch && m.file === file.path && m.position === position
            );
            if (!exists) {
              this.mentions.push({
                text: cleanMatch,
                file: file.path,
                position
              });
            }
          });
        }
      }
      if (this.mentions.length > 0) {
        console.log("Initial mentions found:", this.mentions);
        if (this.mentionsView) {
          await this.mentionsView.setMentions(this.mentions);
        }
        await this.saveData(this.mentions);
      }
      const processor = async (el, ctx) => {
        var _a;
        console.log("MarkdownPostProcessor called for:", ctx.sourcePath);
        console.log("Element content:", el.innerHTML);
        console.log("Current mentions in memory:", this.mentions);
        el.querySelectorAll(".mention-tag").forEach((el2) => el2.remove());
        const codeBlocks = el.querySelectorAll("code");
        console.log("Found code blocks:", codeBlocks.length);
        codeBlocks.forEach((block) => {
          block.addClass("mentions-ignore");
        });
        const walker = document.createTreeWalker(
          el,
          NodeFilter.SHOW_TEXT,
          {
            acceptNode: function(node2) {
              var _a2, _b, _c, _d;
              const isInCodeBlock = (_a2 = node2.parentElement) == null ? void 0 : _a2.closest(".mentions-ignore");
              const isInMention = (_b = node2.parentElement) == null ? void 0 : _b.hasClass("mention-tag");
              console.log("Checking node:", {
                text: node2.textContent,
                isInCodeBlock,
                isInMention,
                parentElement: (_c = node2.parentElement) == null ? void 0 : _c.tagName,
                classList: (_d = node2.parentElement) == null ? void 0 : _d.className
              });
              if (isInCodeBlock || isInMention) {
                return NodeFilter.FILTER_REJECT;
              }
              return NodeFilter.FILTER_ACCEPT;
            }
          }
        );
        const nodesToProcess = [];
        let node;
        let nodeCount = 0;
        while (node = walker.nextNode()) {
          nodeCount++;
          const matchResult = (_a = node.textContent) == null ? void 0 : _a.match(/(?:^|\s)(@[a-zа-я.-]+)/g);
          console.log(`Processing node ${nodeCount}:`, {
            text: node.textContent,
            matchResult
          });
          if (matchResult && matchResult.length > 0) {
            nodesToProcess.push({ node, matches: matchResult });
          }
        }
        console.log(`Found ${nodesToProcess.length} nodes with mentions`);
        nodesToProcess.forEach(({ node: node2, matches }) => {
          let pos = 0;
          let text = node2.textContent || "";
          const fragment = document.createDocumentFragment();
          matches.forEach((match) => {
            const cleanMatch = match.replace(/^\s*/, "");
            const beforeText = text.slice(pos, text.indexOf(match, pos));
            if (beforeText) {
              fragment.append(beforeText);
            }
            const mentionEl = document.createElement("span");
            mentionEl.addClass("mention");
            mentionEl.addClass("mention-tag");
            mentionEl.textContent = cleanMatch;
            mentionEl.style.cursor = "pointer";
            mentionEl.setAttribute("data-mention", cleanMatch);
            const position = text.indexOf(match, pos);
            const mention = {
              text: cleanMatch,
              file: ctx.sourcePath,
              position
            };
            const exists = this.mentions.some(
              (m) => m.text === cleanMatch && m.file === ctx.sourcePath && m.position === position
            );
            if (!exists) {
              console.log("Adding new mention:", mention);
              this.mentions.push(mention);
              this.saveData(this.mentions);
            }
            const clickHandler = async (e) => {
              console.log("Click handler called");
              e.preventDefault();
              e.stopPropagation();
              console.log("Mention clicked:", {
                match: cleanMatch,
                fullText: cleanMatch,
                searchText: cleanMatch.slice(1)
              });
              await this.showMentionResults(cleanMatch.slice(1));
            };
            mentionEl.removeEventListener("click", clickHandler);
            mentionEl.addEventListener("click", clickHandler);
            fragment.append(mentionEl);
            pos = text.indexOf(match, pos) + match.length;
          });
          if (pos < text.length) {
            fragment.append(text.slice(pos));
          }
          node2.replaceWith(fragment);
        });
        if (nodesToProcess.length > 0) {
          console.log("Found new mentions, current state:", {
            newMentions: nodesToProcess.length,
            totalMentions: this.mentions.length,
            mentionsData: this.mentions
          });
          if (this.mentionsView) {
            this.mentionsView.setMentions(this.mentions);
          }
          console.log("Saving mentions to storage...");
          await this.saveData(this.mentions);
          console.log("Mentions saved successfully");
        }
      };
      this.registerMarkdownPostProcessor(processor);
      this.registerEvent(
        this.app.vault.on("modify", async (file) => {
          if (file instanceof import_obsidian.TFile && file.extension === "md") {
            console.log("File modified:", file.path);
            const content = await this.app.vault.read(file);
            console.log("Processing file content for mentions");
            this.mentions = this.mentions.filter((m) => m.file !== file.path);
            const matches = content.match(/(?:^|\s)(@[a-zа-я.-]+)/g);
            if (matches) {
              console.log("Found mentions in file:", matches);
              matches.forEach((match) => {
                const cleanMatch = match.replace(/^\s*/, "");
                const position = content.indexOf(match);
                this.mentions.push({
                  text: cleanMatch,
                  file: file.path,
                  position
                });
              });
            }
            console.log("Updated mentions:", this.mentions);
            if (this.mentionsView) {
              await this.mentionsView.setMentions(this.mentions);
            }
            await this.saveData(this.mentions);
            if (this.settings.autoUpdateProperties) {
              const fileMentions = this.extractMentionsFromContent(content);
              if (fileMentions.length > 0) {
                await this.updateFileProperties(file, fileMentions);
              }
            }
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("delete", async (file) => {
          if (file instanceof import_obsidian.TFile && file.extension === "md") {
            console.log("File deleted:", file.path);
            const beforeCount = this.mentions.length;
            this.mentions = this.mentions.filter((m) => m.file !== file.path);
            const removedCount = beforeCount - this.mentions.length;
            if (removedCount > 0) {
              console.log(`Removed ${removedCount} mentions from deleted file:`, file.path);
              if (this.mentionsView) {
                await this.mentionsView.setMentions(this.mentions);
              }
              await this.saveData(this.mentions);
            }
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("create", async (file) => {
          if (file instanceof import_obsidian.TFile && file.extension === "md") {
            console.log("New file created:", file.path);
            const content = await this.app.vault.read(file);
            const matches = content.match(/(?:^|\s)(@[a-zа-я.-]+)/g);
            if (matches) {
              matches.forEach((match) => {
                const cleanMatch = match.replace(/^\s*/, "");
                const position = content.indexOf(match);
                this.mentions.push({
                  text: cleanMatch,
                  file: file.path,
                  position
                });
              });
              if (this.mentionsView) {
                await this.mentionsView.setMentions(this.mentions);
              }
              await this.saveData(this.mentions);
              if (this.settings.autoUpdateProperties) {
                const fileMentions = this.extractMentionsFromContent(content);
                if (fileMentions.length > 0) {
                  await this.updateFileProperties(file, fileMentions);
                }
              }
            }
          }
        })
      );
      this.registerEvent(
        this.app.vault.on("rename", async (file, oldPath) => {
          if (file instanceof import_obsidian.TFile && file.extension === "md") {
            console.log("File renamed:", { oldPath, newPath: file.path });
            this.mentions = this.mentions.map(
              (mention) => mention.file === oldPath ? { ...mention, file: file.path } : mention
            );
            if (this.mentionsView) {
              await this.mentionsView.setMentions(this.mentions);
            }
            await this.saveData(this.mentions);
          }
        })
      );
      this.registerDomEvent(document, "click", (evt) => {
        const target = evt.target;
        if (target.hasClass("mention-tag")) {
          const mentionText = target.textContent;
          if (mentionText) {
            evt.preventDefault();
            evt.stopPropagation();
            const searchLeaf = this.app.workspace.getLeavesOfType("search")[0] || this.app.workspace.getRightLeaf(false);
            searchLeaf.setViewState({
              type: "search",
              state: { query: mentionText }
            });
            this.app.workspace.revealLeaf(searchLeaf);
          }
        }
      });
      console.log("MentionsPlugin loaded successfully");
    } catch (error) {
      console.error("Error during MentionsPlugin initialization:", error);
      new import_obsidian.Notice("Error initializing Mentions plugin");
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_MENTIONS);
  }
  decorateMentions() {
    return import_state.StateField.define({
      create: () => import_view.Decoration.none,
      update: (decorations, tr) => {
        const text = tr.state.doc.toString();
        const matches = text.match(/(?:^|\s)(@[a-zа-я.-]+)/g);
        const decorationArray = [];
        if (matches) {
          let pos = 0;
          matches.forEach((match) => {
            const fullMatch = match;
            const cleanMatch = match.replace(/^\s*/, "");
            const start = text.indexOf(fullMatch, pos) + (fullMatch.length - cleanMatch.length);
            if (start >= 0) {
              const end = start + cleanMatch.length;
              const mentionMark = import_view.Decoration.mark({
                class: "mention mention-tag",
                attributes: { "data-mention": cleanMatch }
              });
              decorationArray.push(mentionMark.range(start, end));
              pos = end;
            }
          });
        }
        return import_view.Decoration.set(decorationArray, true);
      },
      provide: (field) => import_view.EditorView.decorations.from(field)
    });
  }
};
